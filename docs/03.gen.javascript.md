# Javascript

> Emscripten versions 3.1.42 until 3.1.47 contain a bug that breaks our builds.
>
> Use a version earlier or later with this Generator for functional output.

## Getting Started

Heavy can provide a Javascript (JS) implementation of your patch using WebAssembly. The library provides a basic interface for processing audio, handling playback and sending or receiving messages. Both `AudioWorklet` and `ScriptProcessorNode` are supported. The old `asm.js` implementation has been deprecated.

## Web Preview

The quickest way to try out your patch in the web is to use the pre-generated widget.

Alternatively if you want to use a custom HTML interface it is possible to link against just the javascript library, see below for more instructions on how to do that.

Some [examples](https://github.com/Wasted-Audio/hvcc-examples-js) are hosted on [github pages](https://wasted-audio.github.io/hvcc-examples-js).

## The JS Target

For a more detailed example of running your patch in the web it can be more informative to inspect the JS target.

Heavy provides the following:

| File | Description |
| --- | --- |
| index.html | A simple web page similar to the pre-generated widget |
| dynamic.html | A simple web page similar to the pre-generated widget, dynamically generated and has input support |
| `{PATCH}`.js | The main javascript library to link against, contains the basic [web assembly](http://webassembly.org) compiled binary of the patch. |
| `{PATCH}`_AudioLibWorklet.js | AudioWorklet implementation of the patch, used when AudioWorklet interface is available and provides low latency audio on a separate thread. |

## AudioLibLoader

The `AudioLibLoader` is a helper object that implements the boilerplate code for setting up the [WebAudio](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API) context and making sure the heavy patch is processed correctly. It acts as a wrapper around the `AudioLib`.

This object simplifies the set-up required and should be sufficient for most use cases. However, if you're creating something more specific, for example routing between multiple patches, it's probably best to look into loading the AudioLib manually.

### Set Up

The initial set up should look something like this:

```html

<script type="text/javascript">
  // the AudioLibLoader object
  var heavyModule = null;
  var loader = null;

  // construct a new patch module, this contains all the necessary libraries
  // make sure to replace {PATCH} with the name of your patch
  window.onload = function() {
    {PANRT}_Module().then(loadedModule => {
      heavyModule = loadedModule;
      moduleLoaded();
    });
    document.getElementById("transportButton").style.visibility = "hidden";
  }

  // instantiate the AudioLibLoader object
  function moduleLoaded() {
    loader = new heavyModule.AudioLibLoader();
    document.getElementById("transportButton").style.visibility = "visible";

    // If you are using events or parameters, make sure to have a look through them with your browsers devtools
    console.log(loader.eventsIn); // Dictionary of all input events, marked with [r {name} @hv_event] in the patch
    console.log(loader.eventsOut); // Dictionary of all output events, marked with [s {name} @hv_event] in the patch

    console.log(loader.paramsIn); // Dictionary of all input parameters, marked with [r {name} @hv_param] in the patch
                                  // Full syntax: [r {name} @hv_param {min} {max} {default}]

    console.log(loader.paramsOut); // Dictionary of all output parameters, marked with [s {name} @hv_param] in the patch
                                   // Full syntax: [s {name} @hv_param {min} {max} {default}]
  }

  // starting the processor
  function start() {
    if(!loader.webAudioContext) {

      // this will set up the WebAudio context add a new audio node
      loader.init({
        blockSize: 2048, // number of samples on each audio processing block
        printHook: onPrint, // callback for [print] messages, can be null
        sendHook: onFloatMessage // callback for output parameters [s {name} @hv_param], can be null
      }).then(() => {
        // connect the loader's node to the destination (or another node)
        loader.node.connect(loader.webAudioContext.destination);
      });
    } else {
      loader.node.connect(loader.webAudioContext.destination);
    }
  }

  // stopping the processor
  function stop() {
    loader.node.disconnect(loader.webAudioContext.destination);
  }

  // print callback
  function onPrint(message) {
    console.log(message);
  }

  // output parameter callback
  function onFloatMessage(sendName, floatValue) {
    console.log(sendName, floatValue);
  }

  // ...

</script>
```

### Transport Controls

```html
<script type="text/javascript">
  // ...
  var isPlaying = false;

  // which can be used to toggle the processor
  function toggleTransport(element) {
    (isPlaying) ? stop() : start();
    isPlaying = !isPlaying; //Invert the isPlaying variable
  }

</script>
```

### Sending Events or Parameters

The JS target supports [exposing event and parameter](02.getting_started#exposing-parameters) interfaces from the patch.

```html
<script type="text/javascript">
  // ...

  // send a bang to an event receiver called "Attack"
  loader.sendEvent("Attack");


  // send a float value to a parameter receiver called "Distance"
  loader.setFloatParameter("Distance", 10);


  // Alternatively:
  loader.eventsIn.Attack.fire();
  loader.paramsIn.Distance.setValue(10);

  // You can also read info about each:
  // loader.eventsIn.Attack.displayName - Display name of the event
  // loader.eventsIn.Attack.eventId     - Name of event to fire in sendEvent

  // loader.paramsIn.Distance.min         - Number; the minimum value of the receiver
  // loader.paramsIn.Distance.max         - Number; the maximum value of the receiver
  // loader.paramsIn.Distance.value       - Number; the value of the receiver. Do not update directly, use setValue() instead
  // loader.paramsIn.Distance.default     - Number; the default value of the receiver
  // loader.paramsIn.Distance.type        - String; the type of the receiver. Usually "float"
  // loader.paramsIn.Distance.displayName - String; Display name of the receiver
  // loader.paramsIn.Distance.eventId     - String; Event id of the receiver, for: loader.sendEvent("id", 10)
</script>
```

### Receiving Events or Parameters
```html
<script type="text/javascript">
  // attach to a sender called "VolumeLeft";
  loader.paramsOut.VolumeLeft.onUpdate = () => {
    console.log(loader.paramsOut.VolumeLeft.value);
  };
  // a paramsOut entry has same properties as a paramsIn entry
  // set the onUpdate property to a method and it will run every time the patch updates the value of a sender.

  loader.eventsOut.Bang.onFire = () => {
    console.log("Event triggered!")
  };
  // an eventsOut entry has same properties as an eventsIn entry
  // set the onFire property to a method and it will run every time the patch triggers the event.
</script>
```

## Loading Custom Samples

If you have a table that is externed, using the `@hv_table` annotation, it can be used to load audio files from the web page. The table will be resized to fit this sample data.

`[table array1 100 @hv_table]`

The webAudioContext can load any url, but typically this will be a local path. Modify your html using the following:

```js
      // Sample loading
      function loadAudio(url) {
        var rq = new XMLHttpRequest();
        rq.open("GET", url, true);
        rq.responseType = "arraybuffer";
        rq.send();

        rq.onload = function() {
          var audioData = rq.response;
          loader.webAudioContext.decodeAudioData(audioData, function(buffer){
            loader.fillTableWithFloatBuffer("array1", buffer.getChannelData(0));
          });
        }
      }
```

This can then be called from a user action or any other mechanism that works for you:

```html
<button style="padding: 10px;"  type="button" id="loadButton" onclick="loadAudio('custom_sample.wav');">Load Audio</button>
```

## Inputs

Currently, heavy only supports having one input node and one output node at a time.
```javascript
let oscillator = loader.webAudioContext.createOscillator(); //OscillatorNode, frequency defaults to 440Hz
oscillator.connect(loader.node); //connect the oscillator to the node
```

## MIDI Inputs and outputs
Heavy allows you to send MIDI data back and forth using the [Web MIDI API](https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API).
Sample code:
```javascript
let midi = null; // global MIDIAccess object
function onMIDISuccess(midiAccess) {
  console.log("MIDI ready!");
  midi = midiAccess; // store in the global (in real usage, would probably keep in an object instance)

  midiAccess.inputs[0].onmidimessage = (message)=>{ //send incoming MIDI data to the patch
    loader.sendMidi(message.data);
  }

  var output = midiAccess.outputs[0]; // forward the MIDI data from the patch to a MIDI output
  loader.midiOutEvent.onFire = (message) => {
    output.send(message);
  }
}

function onMIDIFailure(msg) {
  console.error(`Failed to get MIDI access - ${msg}`);
}

navigator.requestMIDIAccess().then(onMIDISuccess, onMIDIFailure);
```