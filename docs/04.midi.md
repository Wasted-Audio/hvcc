#Â MIDI I/O

In PureData there are objects to handle interfacing with a machines MIDI device.

**heavy** doesn't provide cross-platform implementation for MIDI I/O as the requirements tend to change depending on the platform or framework being used.

Instead, it provides wrappers around these objects that route the data to specific hard-coded receivers/parameters in the patch context. For example a `[notein]` object will be replaced by a `[r __hv_notein]` receiver with input data split into its constituent parts and routed to the appropriate outlet.

`[notein]` wrapper implementation:

![notein](img/docs_midi_notein.png)


## Inputs

The following Pd objects are mapped to their corresponding heavy parameter and internal hash.

| Pd object | heavy param    | heavy hash |
| --------- | -------------- | ---------- |
| [notein]  | __hv_notein    | 0x67e37ca3 |
| [ctlin]   | __hv_ctlin     | 0x41be0f9c |
| [pgmin]   | __hv_pgmin     | 0x2e1ea03d |
| [touchin] | __hv_touchin   | 0x553925bd |
| [bendin]  | __hv_bendin    | 0x3083f0f7 |


## Outputs

The same principle applies for sending MIDI data out of the heavy context. If you add a [noteout] object there'll be a corresponding sendhook callback with a message containing the MIDI data sent by the patch.

| Pd object  | heavy sendhook | heavy hash |
| ---------  | -------------- |------------|
| [noteout]  | __hv_noteout   | 0xd1d4ac2  |
| [ctlout]   | __hv_ctlout    | 0xe5e2a040 |
| [pgmout]   | __hv_pgmout    | 0x8753e39e |
| [touchout] | __hv_touchout  | 0x476d4387 |
| [bendout]  | __hv_bendout   | 0xe8458013 |

## Note!

`It is generally the users responsibility to convert to and from the MIDI byte data to the float values used by heavy.`

Some framework targets like [DPF](03.gen.dpf.md) already have implementations available. However, if you're integrating the C/C++ code on a custom platform then you'll need to provide your own conversion process.

Here's the `DPF` implementation as an example.

## Handling MIDI Input

The MIDI input is called during the DPF `run()` loop where it receives `MidiEvent` messages:

```cpp
#if DISTRHO_PLUGIN_WANT_MIDI_INPUT
void {{class_name}}::handleMidiInput(uint32_t curEventIndex, const MidiEvent* midiEvents)
{
  int status = midiEvents[curEventIndex].data[0];
  int command = status & 0xF0;
  int channel = status & 0x0F;
  int data1   = midiEvents[curEventIndex].data[1];
  int data2   = midiEvents[curEventIndex].data[2];

  switch (command) {
    case 0x80: {  // note off
      _context->sendMessageToReceiverV(HV_HASH_NOTEIN, 0, "fff",
        (float) data1, // pitch
        (float) 0, // velocity
        (float) channel);
      break;
    }
    case 0x90: { // note on
      _context->sendMessageToReceiverV(HV_HASH_NOTEIN, 0, "fff",
        (float) data1, // pitch
        (float) data2, // velocity
        (float) channel);
      break;
    }
    case 0xB0: { // control change
      _context->sendMessageToReceiverV(HV_HASH_CTLIN, 0, "fff",
        (float) data2, // value
        (float) data1, // cc number
        (float) channel);
      break;
    }
    case 0xC0: { // program change
      _context->sendMessageToReceiverV(HV_HASH_PGMIN, 0, "ff",
        (float) data1,
        (float) channel);
      break;
    }
    case 0xD0: { // aftertouch
      _context->sendMessageToReceiverV(HV_HASH_TOUCHIN, 0, "ff",
        (float) data1,
        (float) channel);
      break;
    }
    case 0xE0: { // pitch bend
      // combine 7bit lsb and msb into 32bit int
      hv_uint32_t value = (((hv_uint32_t) data2) << 7) | ((hv_uint32_t) data1);
      _context->sendMessageToReceiverV(HV_HASH_BENDIN, 0, "ff",
        (float) value,
        (float) channel);
      break;
    }
    default: break;
  }
}
#endif


#if DISTRHO_PLUGIN_WANT_MIDI_INPUT
void {{class_name}}::run(const float** inputs, float** outputs, uint32_t frames, const MidiEvent* midiEvents, uint32_t midiEventCount)
{
  for (uint32_t i=0; i < midiEventCount; ++i)
  {
    handleMidiInput(i, midiEvents);
  }
#else
void {{class_name}}::run(const float** inputs, float** outputs, uint32_t frames)
{
#endif
```

## Handling MIDI Output

For MIDI output you will need to set a heavy sendhook function that will trigger `DPF` MIDI output events from the heavy context:

```cpp
static void hvSendHookFunc(HeavyContextInterface *c, const char *sendName, uint32_t sendHash, const HvMessage *m)
{
  {{class_name}}* plugin = ({{class_name}}*)c->getUserData();
  if (plugin != nullptr)
  {
#if DISTRHO_PLUGIN_WANT_MIDI_OUTPUT
    plugin->handleMidiSend(sendHash, m);
#endif
  }
}
```

That can then be attached to the heavy context in the constructor:

```cpp
  _context->setUserData(this);
  _context->setSendHook(&hvSendHookFunc);
```

This will prepare the DPF MidiEvents and needs to take special care for Note Off messages.

Pd does not have specific Note Off events, so velocity 0 is assumed to be Note Off in this case.

Bend assumes input and output values ranged `0 - 16383`.

```cpp
#if DISTRHO_PLUGIN_WANT_MIDI_OUTPUT
void {{class_name}}::handleMidiSend(uint32_t sendHash, const HvMessage *m)
{
  MidiEvent midiSendEvent;
  midiSendEvent.frame = 0;
  midiSendEvent.dataExt = nullptr;

  switch(sendHash){
    case HV_HASH_NOTEOUT: // __hv_noteout
    {
      uint8_t note = hv_msg_getFloat(m, 0);
      uint8_t velocity = hv_msg_getFloat(m, 1);
      uint8_t ch = hv_msg_getFloat(m, 2);

      midiSendEvent.size = 3;
      if (velocity > 0){
        midiSendEvent.data[0] = 0x90 | ch; // Note On
      } else {
        midiSendEvent.data[0] = 0x80 | ch; // Note Off
      }
      midiSendEvent.data[1] = note;
      midiSendEvent.data[2] = velocity;
      midiSendEvent.data[3] = 0;

      writeMidiEvent(midiSendEvent);
      break;
    }
    case HV_HASH_CTLOUT:
    {
      uint8_t value = hv_msg_getFloat(m, 0);
      uint8_t cc = hv_msg_getFloat(m, 1);
      uint8_t ch = hv_msg_getFloat(m, 2);

      midiSendEvent.size = 3;
      midiSendEvent.data[0] = 0xB0 | ch; // send CC
      midiSendEvent.data[1] = cc;
      midiSendEvent.data[2] = value;
      midiSendEvent.data[3] = 0;

      writeMidiEvent(midiSendEvent);
      break;
    }
    case HV_HASH_PGMOUT:
    {
      uint8_t pgm = hv_msg_getFloat(m, 0);
      uint8_t ch = hv_msg_getFloat(m, 1);

      midiSendEvent.size = 2;
      midiSendEvent.data[0] = 0xC0 | ch; // send Program Change
      midiSendEvent.data[1] = pgm;
      midiSendEvent.data[2] = 0;
      midiSendEvent.data[3] = 0;

      writeMidiEvent(midiSendEvent);
      break;
    }
    case HV_HASH_TOUCHOUT:
    {
      uint8_t value = hv_msg_getFloat(m, 0);
      uint8_t ch = hv_msg_getFloat(m, 1);

      midiSendEvent.size = 2;
      midiSendEvent.data[0] = 0xD0 | ch; // send Touch
      midiSendEvent.data[1] = value;
      midiSendEvent.data[2] = 0;
      midiSendEvent.data[3] = 0;

      writeMidiEvent(midiSendEvent);
      break;
    }
    case HV_HASH_BENDOUT:
    {
      uint16_t value = hv_msg_getFloat(m, 0);
      uint8_t lsb  = value & 0x7F;
      uint8_t msb  = (value >> 7) & 0x7F;
      uint8_t ch = hv_msg_getFloat(m, 1);

      midiSendEvent.size = 3;
      midiSendEvent.data[0] = 0xE0 | ch; // send Bend
      midiSendEvent.data[1] = lsb;
      midiSendEvent.data[2] = msb;
      midiSendEvent.data[3] = 0;

      writeMidiEvent(midiSendEvent);
      break;
    }
    default:
      break;
  }
}
#endif
```